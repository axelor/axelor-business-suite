/**
 * Axelor Business Solutions
 *
 * Copyright (C) 2016 Axelor (<http://axelor.com>).
 *
 * This program is free software: you can redistribute it and/or  modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.axelor.studio.service.builder;

import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.axelor.common.Inflector;
import com.axelor.meta.db.MetaField;
import com.axelor.meta.db.MetaJsonField;
import com.axelor.meta.db.MetaJsonRecord;
import com.axelor.meta.db.MetaModel;
import com.axelor.meta.db.repo.MetaFieldRepository;
import com.axelor.meta.db.repo.MetaJsonFieldRepository;
import com.axelor.meta.db.repo.MetaModelRepository;
import com.axelor.meta.loader.XMLViews;
import com.axelor.meta.schema.ObjectViews;
import com.axelor.meta.schema.actions.ActionRecord;
import com.axelor.meta.schema.actions.ActionRecord.RecordField;
import com.axelor.meta.schema.views.AbstractView;
import com.axelor.studio.db.Filter;
import com.axelor.studio.db.ViewBuilder;
import com.axelor.studio.service.FilterService;
import com.google.inject.Inject;

/**
 * This class generate charts using ViewBuilder and chart related fields. Chart
 * xml generated by adding query, search fields , onInit actions..etc. All
 * filters with parameter checked will be used as search fields. Tags also there
 * to use context variable in filter value, like $User for current user
 * (__user__).
 */

public class ChartBuilderService {

	private final Logger log = LoggerFactory.getLogger( MethodHandles.lookup().lookupClass() );

	private static final String Tab1 = "\n \t";
	private static final String Tab2 = "\n \t\t";
	private static final String Tab3 = "\n \t\t\t";

	private List<String> searchFields;

	private ActionRecord onNewAction;

	private List<RecordField> onNewFields;

	@Inject
	private MetaModelRepository metaModelRepo;
	
	@Inject
	private FilterService filterService;
	
	/**
	 * Root Method to access the service it generate AbstractView from
	 * ViewBuilder.
	 * 
	 * @param viewBuilder
	 *            ViewBuilder object of type chart.
	 * @return AbstractView from meta schema.
	 * @throws JAXBException
	 */
	public AbstractView getView(ViewBuilder viewBuilder) throws JAXBException {

		searchFields = new ArrayList<String>();
		onNewFields = new ArrayList<RecordField>();
		onNewAction = null;

		String[] queryString = prepareQuery(viewBuilder);
		setOnNewAction(viewBuilder);

		String xml = "<chart name=\"" + viewBuilder.getName() + "\" title=\""
				+ viewBuilder.getTitle() + "\" ";

		if (onNewAction != null) {
			xml += " onInit=\"" + onNewAction.getName() + "\" ";
		}
		xml += ">\n";
		if (!searchFields.isEmpty()) {
			xml += "\t" + getSearchFields() + "\n";
		}
		
		String groupLabel = viewBuilder.getIsJsonGroupOn() ? viewBuilder.getGroupOnJson().getTitle() : viewBuilder.getGroupOn().getLabel();
		String displayLabel = viewBuilder.getIsJsonDisplayField() ? viewBuilder.getDisplayFieldJson().getTitle() : viewBuilder.getDisplayField().getLabel();
		xml += "\t<dataset type=\"sql\">";
		xml += Tab2 + queryString[0];
		xml += Tab2 + "</dataset>";
		xml += Tab1 + "<category key=\"group_field\" type=\"text\" title=\""
				+ groupLabel  + "\" />";
		xml += Tab1 + "<series key=\"sum_field\" type=\""
				+ viewBuilder.getChartType() + "\" title=\""
				+ displayLabel + "\" ";
		if (queryString[1] != null) {
			xml += "group by=\"agg_field\" ";
		}
		xml += "/>\n";
		xml += "</chart>";

		log.debug("Chart xml: {}", xml);

		ObjectViews chartView = XMLViews.fromXML(xml);

		return chartView.getViews().get(0);
	}

	/**
	 * Method to get generated on onNew ActionRecord during view generation.
	 * 
	 * @return ActionRecord class of meta schema.
	 */
	public ActionRecord getOnNewAction() {

		log.debug("On new chart: {}", onNewAction);

		return onNewAction;
	}

	/**
	 * Method create query from chart filters added in chart builder.
	 * 
	 * @param viewBuilder
	 *            ViewBuilder of type chart
	 * @return StringArray with first element as query string and second as
	 *         aggregate field name.
	 */
	private String[] prepareQuery(ViewBuilder viewBuilder) {
		
		String query = null;
		
		if (viewBuilder.getIsJsonDisplayField()) {
			MetaJsonField jsonField = viewBuilder.getDisplayFieldJson();
			String sqlType = filterService.getSqlType(jsonField.getType());
			query = "SELECT" + Tab3 + "SUM(cast(self." + jsonField.getModelField() 
					+ "->>'" + jsonField.getName() + "' as " + sqlType + ")) AS sum_field," + Tab3;
		}else {
			query = "SELECT" + Tab3 + "SUM(self."
					+ viewBuilder.getDisplayField().getName() + ") AS sum_field,"
					+ Tab3;
		}
		
		Object targetOn = viewBuilder.getIsJsonGroupOn() ? viewBuilder.getGroupOnJson()  : viewBuilder.getGroupOn();
		String groupField = getGroupFieldName(targetOn,
				viewBuilder.getGroupDateType(), viewBuilder.getGroupOnTarget());
		
		targetOn = viewBuilder.getIsJsonGroupOn() ? viewBuilder.getAggregateOnJson() : viewBuilder.getAggregateOn();
		String aggField = getGroupFieldName(targetOn,
				viewBuilder.getAggregateDateType(),
				viewBuilder.getAggregateOnTarget());

		query += groupField + " AS group_field";

		if (aggField != null) {
			query += "," + Tab3 + aggField + " AS agg_field";
		}
		
		String model = viewBuilder.getModel();
		String[] filters = createFilters(viewBuilder.getFilterList());
		
		if (viewBuilder.getIsJson()) {
			if (filters[0] != null) {
				filters[0] = "self.json_model = '" + model + "' AND (" + filters[0] + ")";
			}
			else {
				filters[0] = "self.json_model = '" + model + "'" ;
			}
			model = MetaJsonRecord.class.getName();
		}
		
		query += Tab2 + "FROM " + Tab3 +  getTable(model) + " self";
		
		if (filters[1] != null) {
			query += filters[1];
		}

		if (filters[0] != null) {
			query += Tab2 + "WHERE " + Tab3 + filters[0];
		}

		query += Tab2 + "group by " + Tab3 + groupField;

		if (aggField != null) {
			query += "," + aggField;
		}

		return new String[] { query, aggField };
	}
	
	/**
	 * Method to get correct format of group field use to add in query
	 * 
	 * @param metaField
	 *            Group field name selected in chart builder.
	 * @param dateType
	 *            Type of date (month,year,day) selected for group field.
	 * @return Group field string.
	 */
	private String getGroupFieldName(Object groupOn, String dateType,
			String target) {

		if (groupOn == null) {
			return null;
		}
		
		boolean isJson = groupOn instanceof MetaJsonField;
		
		String name = null;
		String typeName = null;
		if (isJson) {
			MetaJsonField jsonField = (MetaJsonField) groupOn; 
			name = jsonField.getName();
			if (target != null) {
				name = target;
			}
			name =  "self." + jsonField.getModelField() + "->>'" + name + "'";
			typeName = jsonField.getType();
		}
		else {
			MetaField metaField = (MetaField) groupOn;
			name = "self." + metaField.getName();
			if (target != null) {
				name = "self." + target;
			}
			typeName = metaField.getTypeName();
			
		}
		
		if (dateType != null) {
			String dtype = "timestamp";
			if ("Date,date,LocalDate".contains(typeName)) {
				dtype = "date";
			}
			switch (dateType) {
			case "year":
				return "to_char(cast(" + name + " as " + dtype +"), 'yyyy')";
			case "month":
				return "to_char(cast(" + name + " as " + dtype +"), 'yyyy-mm')";
			default:
				return name;
			}

		} 
		
		return name;

	}

	/**
	 * Method generate xml for search-fields.
	 * 
	 * @return
	 */
	private String getSearchFields() {

		String search = "<search-fields>";

		for (String searchField : searchFields) {
			search += Tab2 + searchField;
		}
		search += Tab1 + "</search-fields>";

		return search;
	}

	/**
	 * Method set default value for search-fields(parameters). It will add field
	 * and expression in onNew for chart.
	 * 
	 * @param fieldName
	 *            Name of field of search-field.
	 * @param typeName
	 *            Type of field.
	 * @param defaultValue
	 *            Default value input in chart filter.
	 * @param modelField
	 *            It is for relational field. String array with first element as
	 *            Model name and second as its field.
	 */
	private void setDefaultValue(String fieldName, String typeName,
			String defaultValue, String[] modelField) {

		if (defaultValue == null) {
			return;
		}

		RecordField field = new RecordField();
		field.setName(fieldName);

		defaultValue = filterService.getTagValue(defaultValue, false);

		if (modelField != null) {
			if (typeName.equals("STRING")) {
				defaultValue = "__repo__(" + modelField[0]
						+ ").all().filter(\"LOWER(" + modelField[1] + ") LIKE "
						+ defaultValue + "\").fetchOne()";
			} else {
				defaultValue = "__repo__(" + modelField[0]
						+ ").all().filter(\"" + modelField[1] + " = "
						+ defaultValue + "\").fetchOne()";
			}

		}

		log.debug("Default value: {}", defaultValue);

		field.setExpression("eval:" + defaultValue);

		onNewFields.add(field);
	}

	/**
	 * It will create onNew action from onNew fields.
	 * 
	 * @param viewBuilder
	 *            ViewBuilder use to get model name also used in onNew action
	 *            name creation.
	 */
	private void setOnNewAction(ViewBuilder viewBuilder) {

		if (!onNewFields.isEmpty()) {
			onNewAction = new ActionRecord();
			onNewAction.setName("action-" + viewBuilder.getName() + "-default");
			onNewAction.setModel(viewBuilder.getModel());
			onNewAction.setFields(onNewFields);
		}

	}

	private String[] createFilters(List<Filter> filterList) {

		String filters = null;
		String joins = null;

		int count = 0;

		for (Filter filter : filterList) {

			MetaField field = filter.getMetaField();
			MetaJsonField json = filter.getMetaJsonField();

			String relationship = filter.getIsJson() ? json.getTargetModel() : field.getRelationship();
			String condition = "";

			if (relationship != null) {
				String[] relCondition = filterService.getRelationalSql(filter, count);
				filters = relCondition[0];
				if (relCondition[1] != null) {
					joins += relCondition[1];
				}
				count++;
			} else {
				condition = filterService.getSimpleSql(filter);
			}

			if (filter.getIsParameter()) {
				Object searchField = filter.getIsJson() ? json : field;
				addSearchField(filter.getId(), searchField, filter.getTargetField(),
						filter.getDefaultValue());
			}

			if (filters == null) {
				filters = condition;
			} else {
				String opt = filter.getLogicOp() == 0 ? " AND " : " OR ";
				filters = filters + opt + condition;
			}
		}

		return new String[]{filters, joins};

	}

	private void addSearchField(Long filterId, Object field, String targetField,
			String defaultVal) {

		field = filterService.getTargetField(field, targetField, null, 0).get(1);
		boolean json = field instanceof MetaJsonField;
		String fieldStr = "param" + filterId;
		if (json) {
			fieldStr = getJsonSearchField(fieldStr, (MetaJsonField) field);
		}
		else {
			fieldStr = getMetaSearchField(fieldStr, (MetaField) field);
		}

		searchFields.add(fieldStr + "\" x-required=\"true\" />");

//		setDefaultValue(fieldName, typeName, defaultVal, modelField);

	}
	
	private String getMetaSearchField(String fieldStr, MetaField field) {
		
		fieldStr = "<field name=\"" + fieldStr + "\" title=\"" + field.getLabel();

		if (field.getRelationship() ==  null) {
			String fieldType = filterService.getFieldType(field);
			fieldStr += "\" type=\"" + fieldType;
		}
		else {
			String targetRef = metaModelRepo.findByName(field.getTypeName()).getFullName();
			fieldStr += "\" type=\"reference\" target=\"" + targetRef;
		}
		
		return fieldStr;
	}
	
	private String getJsonSearchField(String fieldStr, MetaJsonField field) {
		
		fieldStr = "<field name=\"" + fieldStr + "\" title=\"" + field.getTitle();

		if (field.getTargetJsonModel() == null || field.getTargetModel() == null) {
			String fieldType = Inflector.getInstance().camelize(field.getType(), true);
			fieldStr += "\" type=\"" + fieldType;
		}
		else {
			if (field.getTargetJsonModel() != null) {
				fieldStr += "\" type=\"reference\" target=\"com.axelor.meta.db.MetaJsonRecord\" domain=\"self.json_model = '" + field.getTargetJsonModel() + "'"; 
			}
			else {
				fieldStr += "\" type=\"reference\" target=\"" + field.getTargetModel();
			}
		}
			
		return fieldStr;
	}

	private String getTable(String model) {
		
		String[] models = model.split("\\.");
		MetaModel metaModel = metaModelRepo.findByName(models[models.length - 1]);
		
		if (metaModel != null) {
			return metaModel.getTableName();
		}
		
		return null;
	}
	
}
