/**
 * Axelor Business Solutions
 *
 * Copyright (C) 2016 Axelor (<http://axelor.com>).
 *
 * This program is free software: you can redistribute it and/or  modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.axelor.studio.service.builder;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.axelor.common.Inflector;
import com.axelor.meta.db.MetaField;
import com.axelor.meta.db.MetaJsonField;
import com.axelor.meta.db.repo.MetaModelRepository;
import com.axelor.meta.loader.XMLViews;
import com.axelor.meta.schema.ObjectViews;
import com.axelor.meta.schema.actions.ActionRecord;
import com.axelor.meta.schema.actions.ActionRecord.RecordField;
import com.axelor.meta.schema.views.AbstractView;
import com.axelor.studio.db.Filter;
import com.axelor.studio.db.ViewBuilder;
import com.axelor.studio.service.FilterService;
import com.axelor.studio.service.ViewLoaderService;
import com.google.inject.Inject;

/**
 * This class generate charts using ViewBuilder and chart related fields. Chart
 * xml generated by adding query, search fields , onInit actions..etc. All
 * filters with parameter checked will be used as search fields. Tags also there
 * to use context variable in filter value, like $User for current user
 * (__user__).
 */

public class ChartBuilderService {

	private final Logger log = LoggerFactory.getLogger(getClass());

	private static final String Tab1 = "\n \t";
	private static final String Tab2 = "\n \t\t";
	private static final String Tab3 = "\n \t\t\t";

	private List<String> searchFields;

	private ActionRecord onNewAction;

	private List<RecordField> onNewFields;

	@Inject
	private ViewLoaderService viewLoaderService;

	@Inject
	private FilterService filterService;

	@Inject
	private MetaModelRepository metaModelRepo;

	/**
	 * Root Method to access the service it generate AbstractView from
	 * ViewBuilder.
	 * 
	 * @param viewBuilder
	 *            ViewBuilder object of type chart.
	 * @return AbstractView from meta schema.
	 * @throws JAXBException
	 */
	public AbstractView getView(ViewBuilder viewBuilder) throws JAXBException {

		searchFields = new ArrayList<String>();
		onNewFields = new ArrayList<RecordField>();
		onNewAction = null;

		String[] queryString = prepareQuery(viewBuilder);
		setOnNewAction(viewBuilder);

		String xml = "<chart name=\"" + viewBuilder.getName() + "\" title=\""
				+ viewBuilder.getTitle() + "\" ";

		if (onNewAction != null) {
			xml += " onInit=\"" + onNewAction.getName() + "\" ";
		}
		xml += ">\n";
		if (!searchFields.isEmpty()) {
			xml += "\t" + getSearchFields() + "\n";
		}
		
		String groupLabel = viewBuilder.getIsJsonGroupOn() ? viewBuilder.getGroupOnJson().getTitle() : viewBuilder.getGroupOn().getLabel();
		String displayLabel = viewBuilder.getIsJsonDisplayField() ? viewBuilder.getDisplayFieldJson().getTitle() : viewBuilder.getDisplayField().getLabel();
		xml += "\t<dataset type=\"jpql\">";
		xml += Tab2 + queryString[0];
		xml += Tab2 + "</dataset>";
		xml += Tab1 + "<category key=\"groupField\" type=\"text\" title=\""
				+ groupLabel  + "\" />";
		xml += Tab1 + "<series key=\"fieldSum\" type=\""
				+ viewBuilder.getChartType() + "\" title=\""
				+ displayLabel + "\" ";
		if (queryString[1] != null) {
			xml += "groupBy=\"aggField\" ";
		}
		xml += "/>\n";
		xml += "</chart>";

		log.debug("Chart xml: {}", xml);

		ObjectViews chartView = XMLViews.fromXML(xml);

		return chartView.getViews().get(0);
	}

	/**
	 * Method to get generated on onNew ActionRecord during view generation.
	 * 
	 * @return ActionRecord class of meta schema.
	 */
	public ActionRecord getOnNewAction() {

		log.debug("On new chart: {}", onNewAction);

		return onNewAction;
	}

	/**
	 * Method create query from chart filters added in chart builder.
	 * 
	 * @param viewBuilder
	 *            ViewBuilder of type chart
	 * @return StringArray with first element as query string and second as
	 *         aggregate field name.
	 */
	private String[] prepareQuery(ViewBuilder viewBuilder) {
		
		String query = null;
		String jsonFunction = null;
		MetaJsonField jsonField = null;
		
		if (viewBuilder.getIsJsonDisplayField()) {
			jsonField = viewBuilder.getDisplayFieldJson();
			jsonFunction = filterService.getJsonJpql(jsonField);
			query = "SELECT" + Tab3 + "SUM(" + jsonFunction + "(self."
				+ viewBuilder.getDisplayFieldJson().getModelField() + ",'" + viewBuilder.getDisplayFieldJson().getName() + "')) AS fieldSum,"
				+ Tab3;
		}else {
			query = "SELECT" + Tab3 + "SUM(self."
					+ viewBuilder.getDisplayField().getName() + ") AS fieldSum,"
					+ Tab3;
		}
		
		Object targetOn = viewBuilder.getIsJsonGroupOn() ? viewBuilder.getGroupOnJson()  : viewBuilder.getGroupOn();
		String groupField = getGroupFieldName(targetOn,
				viewBuilder.getGroupDateType(), viewBuilder.getGroupOnTarget());
		
		targetOn = viewBuilder.getIsJsonGroupOn() ? viewBuilder.getAggregateOnJson() : viewBuilder.getAggregateOn();
		String aggField = getGroupFieldName(targetOn,
				viewBuilder.getAggregateDateType(),
				viewBuilder.getAggregateOnTarget());

		query += groupField + " AS groupField";

		if (aggField != null) {
			query += "," + Tab3 + aggField + " AS aggField";
		}

		query += Tab2 + "FROM " + Tab3 + viewBuilder.getMetaModel().getName()
				+ " self";

		String filters = createFilters(viewBuilder.getFilterList());

		if (filters != null) {
			query += Tab2 + "WHERE " + Tab3 + filters;
		}

		query += Tab2 + "GROUP BY " + Tab3 + groupField;

		if (aggField != null) {
			query += "," + aggField;
		}

		return new String[] { query, aggField };
	}

	/**
	 * Method to get correct format of group field use to add in query
	 * 
	 * @param metaField
	 *            Group field name selected in chart builder.
	 * @param dateType
	 *            Type of date (month,year,day) selected for group field.
	 * @return Group field string.
	 */
	private String getGroupFieldName(Object groupOn, String dateType,
			String target) {

		if (groupOn == null) {
			return null;
		}
		
		boolean isJson = groupOn instanceof MetaJsonField;
		
		String name = null;
		String typeName = null;
		if (isJson) {
			MetaJsonField jsonField = (MetaJsonField) groupOn; 
			name = jsonField.getName();
			if (target != null) {
				name = target;
			}
			name = filterService.getJsonJpql(jsonField) + "(self." + jsonField.getModelField() + ",'" + name + "')";
			typeName = jsonField.getType();
		}
		else {
			MetaField metaField = (MetaField) groupOn;
			name = "self." + metaField.getName();
			if (target != null) {
				name = "self." + target;
			}
			typeName = metaField.getTypeName();
			
		}
		
		if (dateType != null
				&& "Date,DateTime,LocalDate,ZonedDateTime,LocalDateTime,date,datetime".contains(typeName)) {
			String dtype = "datetime";
			if ("Date,date,LocalDate".contains(typeName)) {
				dtype = "date";
			}
			switch (dateType) {
			case "year":
				return "YEAR(cast(" + name + " as " + dtype +")";
			case "month":
				return "concat(str(YEAR(cast(" + name + " as " + dtype + "))), '-',str(MONTH(cast(" + name + " as " + dtype +"))))";
			default:
				return name;
			}

		} 
		
		return name;

	}

	/**
	 * Method generate xml for search-fields.
	 * 
	 * @return
	 */
	private String getSearchFields() {

		String search = "<search-fields>";

		for (String searchField : searchFields) {
			search += Tab2 + searchField;
		}
		search += Tab1 + "</search-fields>";

		return search;
	}

	/**
	 * Method set default value for search-fields(parameters). It will add field
	 * and expression in onNew for chart.
	 * 
	 * @param fieldName
	 *            Name of field of search-field.
	 * @param typeName
	 *            Type of field.
	 * @param defaultValue
	 *            Default value input in chart filter.
	 * @param modelField
	 *            It is for relational field. String array with first element as
	 *            Model name and second as its field.
	 */
	private void setDefaultValue(String fieldName, String typeName,
			String defaultValue, String[] modelField) {

		if (defaultValue == null) {
			return;
		}

		RecordField field = new RecordField();
		field.setName(fieldName);

		defaultValue = filterService.getTagValue(defaultValue, false);

		if (modelField != null) {
			if (typeName.equals("STRING")) {
				defaultValue = "__repo__(" + modelField[0]
						+ ").all().filter(\"LOWER(" + modelField[1] + ") LIKE "
						+ defaultValue + "\").fetchOne()";
			} else {
				defaultValue = "__repo__(" + modelField[0]
						+ ").all().filter(\"" + modelField[1] + " = "
						+ defaultValue + "\").fetchOne()";
			}

		}

		log.debug("Default value: {}", defaultValue);

		field.setExpression("eval:" + defaultValue);

		onNewFields.add(field);
	}

	/**
	 * It will create onNew action from onNew fields.
	 * 
	 * @param viewBuilder
	 *            ViewBuilder use to get model name also used in onNew action
	 *            name creation.
	 */
	private void setOnNewAction(ViewBuilder viewBuilder) {

		if (!onNewFields.isEmpty()) {
			onNewAction = new ActionRecord();
			onNewAction.setName("action-" + viewBuilder.getName() + "-default");
			onNewAction.setModel(viewBuilder.getModel());
			onNewAction.setFields(onNewFields);
		}

	}

	private String createFilters(List<Filter> filterList) {

		String filters = null;

		for (Filter filter : filterList) {

			MetaField field = filter.getMetaField();
			MetaJsonField json = filter.getMetaJsonField();

			String relationship = filter.getIsJson() ? json.getTargetModel() : field.getRelationship();
			String condition = "";

			if (relationship != null) {
				condition = filterService.getRelationalCondition(filter, null);
			} else {
				condition = filterService.getSimpleCondition(filter, null);
			}

			if (filter.getIsParameter()) {
				Object searchField = filter.getIsJson() ? json : field;
				addSearchField(searchField, filter.getTargetField(),
						filter.getDefaultValue());
			}

			if (filters == null) {
				filters = condition;
			} else {
				String opt = filter.getLogicOp() == 0 ? " AND " : " OR ";
				filters = filters + opt + condition;
			}
		}

		return filters;

	}

	private void addSearchField(Object field, String targetField,
			String defaultVal) {

		field = filterService.getTargetField(field, targetField)
				.get(1);
		boolean json = field instanceof MetaJsonField;
		MetaJsonField jsonField = null;
		MetaField metaField = null;
		if (json) {
			jsonField = (MetaJsonField) field;
		}
		else {
			metaField = (MetaField) field;
		}
		String relationship = json ?  jsonField.getTargetModel() : metaField.getRelationship();
		String fieldName = json ? jsonField.getName() : metaField.getName();
		String fieldLabel = json ? jsonField.getTitle() : metaField.getLabel();
		String typeName = json ? jsonField.getType() : metaField.getTypeName();
		String fieldStr = "<field name=\"" + fieldName + "\" title=\""
				+ fieldLabel;
		String[] modelField = null;

		if (relationship == null) {
			String fieldType = json ? Inflector.getInstance().camelize(typeName) : viewLoaderService.getFieldType(metaField);
			fieldStr += "\" type=\"" + fieldType;
			String select = json ? jsonField.getSelection() : metaField.getMetaSelect() != null ? metaField.getMetaSelect().getName() : null;
			if (select != null) {
				fieldStr = fieldStr + "\" selection=\"" + select;
			}
		} else {
			String targetRef = metaModelRepo.findByName(typeName).getFullName();
			fieldStr += "\" type=\"reference\" target=\"" + targetRef;
			modelField = new String[] { typeName, "self." + fieldName };
		}

		searchFields.add(fieldStr + "\" x-required=\"true\" />");

		setDefaultValue(fieldName, typeName, defaultVal, modelField);

	}

}
